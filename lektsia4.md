# Краткий конспект лекции: Классы, конструкторы и деструкторы

## Парадигма программирования 
+ **Парадигма** - набор правил и подходов к написанию программ.
+ **ООП(Объектно-ориентированное программирование)** - методология, основанная на работе с объектами и классами, которая улучшает управляемость крупными проектами.

### Основные принципы ООП
+ **Абстрагирование** - выделение ключевых характеристик объектов.
+ **Инкапсуляция** - объединение данных методов в одном классе.
+ **Наследование** - классы могут наследовать поведение и свойства других классов.
+ **Полиморфизм** - возможность объектов вести себя по-разному, используя единый интерфейс.

### Преимущества ООП
+ Упрощает проектирование и понимание кода.
+ Улучшает повторное использование кода и поддерживаемость.
+ Операции с данными связаными с самими данными, что повышает читабельность и логичность.

### Критика ООП
+ Производительность программ на ООП ниже, чем у структурных программ.
+ Разработка может быть сложнее и требует больше ресурсов.
+ Проблемы с конкретными реализациями языков ООП, например, в С++.

### Классы в С++
+ **Класс** - это структура, которая содержит данные (поля) и методы для работы с этими данными.
+ Пример:
    ```cpp
        class Point{
            public:
                int x = 0;
                int y = 0;
                void printPoint(){
                    cout << "(" << x << ", " << y << ")" << endl;
                }
                int getX() {
                    return this->x;
                };
                int getY(){
                    return this->y;
                }
                Point(int x_value, int y_value){
                    x = x_value;
                    y = y_value;
                }
        };
        
        int main(){
            Point p(12, 10);
            p.printPoint(); // (12, 10)
            cout << "(" << p.getX() << ", " << p.getY() << ")" << endl; // (12, 10)
            cout << "(" << p.x << ", " << p.y << ")" << endl; // (12, 10)
            return 0;
        }
    ```

### Конструкторы 
+ **Конструктор** - метод, вызываемый при создании объекта для инициализации его полей.

```
class <наименование класса> {
    public:
        <наименование класса> (<параметры конструктора>){
            // блок кода
        }
};
```
```cpp
class Point{
    public:
        // ...
        Point(int x_value, int y_value){
            x = x_value;
            y = y_value;
        }
        // ...
};
```
+ **Конструктор по умолчанию** - контсруктор без параметорв.
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (){
            // Код конструктора
        }
};
```
```cpp
class Point{
    public:
        // ...
        Point(){
            x = 0;
            y = 0;
        }
        // ...
};
```
+  **Конструктор присвоения** - В С++, несмотря на то что он является уже достаточно старым языком имеется определенный набор конструкций которые упрощают написанный код, сокращая его. К таким конструкциям относиться и особый подвид конструктора, это короткий конструктор присвоения, сигнатура такого конструктора следующая:
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (<тип поля> <наименование аргумента>): <наименование поля>(<наименование аргумента>){}
};
```
```cpp
class Point{
    public:
        // ...
        Point(int x_value, int y_value): x(x_value), y(y_value){}
        // ...
};
```
+  **Конструктор копирования** - создает копию объекта. Важен для объектов с динамической память (например, при использовании указателей).
```
class <Наименование класса> {
    public:
        <тип поля> <наименование поля>;
        <наименование класса> (const <наименование класса>& <наименование аргумента>){
            // код копирования
        }
```

```cpp
class Point{
    public:
        int x = 0;
        int y = 0;
        double* error;
        void printPoint(){
            cout << "(" << x << ", " << y << ")" << endl;
        }
        void printAddress(){
            cout << this << endl;
        }
        Point(int x, int y){
            this->x = x;
            this->y = y;
            this->error = new double {0.5};
        }
};

int main(){
    Point p(12, 10);
    p.printPoint(); // (12, 10)
    p.printAddress(); // 0x61fe10
    cout << p.error << endl; // 0x194200
    Point p2 = p;
    p2.printPoint(); // (12, 10)
    p2.printAddress(); // 0x61fe00
    cout << p2.error << endl; // 0x194200
    return 0;
}
```

Со своим собественным конструктором копирования получится следующий код:
```cpp
class Point{
    public:
        int x = 0;
        int y = 0;
        double* error;
        void printPoint(){
            cout << "(" << x << ", " << y << ")" << endl;
        }
        void printAddress(){
            cout << this << endl;
        }
        Point(int x, int y){
            this->x = x;
            this->y = y;
            this->error = new double {0.5};
        }
        Point(const Point& point){
            this->x = point.x;
            this->y = point.y;
            this->error = new double {*point.error};
        }
};

int main(){
    Point p(12, 10);
    p.printPoint(); // (12, 10)
    p.printAddress(); // 0x61fe10
    cout << p.error << endl; // 0x6e4220
    Point p2 = p;
    p2.printPoint(); // (12, 10)
    p2.printAddress(); // 0x61fe00
    cout << p2.error << endl; // 0x6e4260
    return 0;
}
```

### Деструктор
+ **Деструктор** - метод, вызываемый при удалении объекта, используется для освобождения ресурсов (например, памяти).
+ Пример:
```cpp
class Point{
    public:
        // ...
        ~Point(){
            delete error;
        }
        // ...
}
```

### Указатель ```this```
+ ```this``` - указатель на текущий объект классса. Используется для доступа к полям и методам объекта.

### RAII
+ **RAII (Resource Acquisition Is Initialisation)** - получение и освобождение ресурсов (например, файлов) через конструкторы и деструкторы.

### Правило трех
+ Если класс использует динамическую память, обязательно необходимо реализовать:
    + Конструктор копирования.
    + Оператор присваивания.
    + Деструктор.

