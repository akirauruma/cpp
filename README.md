## 1.  Что такое соглашение об именовании, зачем оно используется? ##
Соглашение об именовании — это набор правил оформления кода, установленных командой разработчиков или организацией. Оно упрощает взаимодействие в команде, позволяя легко различать элементы кода благодаря единому стилю.
## 2. Какие три этапа проходит написанный при сборке скомпилированной программы? В чем суть этих этапов? ##
+ **Препроцессинг**
Препроцессор обрабатывает директивы, такие как #include и #define, и объединяет файлы .cpp и .h с одинаковыми именами.

+ **Компиляция**
Код преобразуется из понятного людям в машинный, проходя токенизацию, синтаксический и семантический анализ. Также выполняется оптимизация кода.

+ **Связывание (линковка)**
Линковщик объединяет скомпилированные единицы трансляции, связывает вызовы функций с их определениями и формирует готовую исполняемую программу.
## 3. Что такое единица трансляции, на каком этапе сборки программы происходит объединение единиц трансляции, в чем заключается суть процесса объединения? ##
Единица трансляции — это максимальный объем кода, который компилятор обрабатывает за один раз. Она включает содержимое одного .cpp файла и подключенные через #include заголовочные файлы.

Объединение единиц трансляции происходит на этапе связывания (линковки).

Суть процесса объединения заключается в следующем:

+ Линковщик связывает все скомпилированные единицы трансляции в один исполняемый файл.
+ Он сопоставляет вызовы функций, переменных и других элементов между различными единицами, разрешая их зависимости.
+ Объединяются также внешние объекты и библиотеки, если они используются

## 4. На какие этапы подразделяет процесс компиляции одной единицы трансляции? В чем их суть? ##

Процесс компиляции одной единицы трансляции подразделяется на следующие этапы:

#### Токенизация ####
Код разбивается на минимальные значимые элементы (токены), такие как ключевые слова, идентификаторы, операторы, и т.д. Например, строка int a = 42; превращается в токены: int, a, =, 42, ;. Пробелы и отступы игнорируются.

#### Синтаксический анализ ####
Проверяется корректность структуры кода с точки зрения синтаксиса. Например, проверяется правильность написания типов, переменных, функций, а также их расположение и оформление. Это аналог проверки орфографии в тексте.

#### Семантический анализ #### 
Проверяется смысловая правильность кода. Компилятор анализирует последовательность токенов, чтобы убедиться, что они составляют осмысленные конструкции, например, правильность типов в выражениях и соответствие переданных аргументов функциям.

#### Оптимизация ####
Код преобразуется для повышения эффективности. Компилятор сокращает лишние вычисления, разворачивает циклы, вставляет литералы, убирает ненужные ветвления и применяет другие оптимизации.

#### Генерация промежуточного кода ####
Код на языке высокого уровня преобразуется в промежуточное представление, более близкое к машинному коду (например, условно похожее на C). Это помогает убрать абстракции, такие как классы, не поддерживаемые напрямую оборудованием.

#### Генерация объектного кода ####
Компилятор создает машинный код для данной единицы трансляции, включая адресацию локальных переменных и функций. Неизвестные внешние ссылки оставляются для разрешения на этапе связывания.
## 5. На какие два этапа подразделяется выделение переменной? Могут ли они быть разнесены в программе? Что будет хранится в переменной если не установить ее значение? ##
Процесс выделения переменной подразделяется на два этапа:

#### Декларирование (объявление) ####
Это процесс резервирования имени для переменной. После декларации переменной ее можно использовать в коде для обращения к выделенной области памяти. Пример:

```cpp
int a;
```
Здесь объявляется переменная a типа int, но ей не присваивается значение.

#### Инициализация ####
Это процесс присвоения переменной первого значения. Пример:

```cpp
int a = 0;
```
Здесь переменная a сразу инициализируется значением 0.

Могут ли этапы быть разнесены в программе?
Да, они могут быть разнесены. Например:

```cpp
int a;  // Декларация
a = 5;  // Присвоение значения
```

Однако присвоение значения позже не считается инициализацией, так как инициализация происходит только в момент объявления переменной.

Что будет храниться в переменной, если не установить ее значение?
Если переменной не присвоено значение, она содержит "мусорное значение" — случайное значение, оставшееся в памяти, выделенной для этой переменной. Это значение зависит от содержимого памяти, используемой под переменную, и его поведение непредсказуемо.

## 6. На какие две группы делятся типы? Назовите примеры. ##
Типы делятся на две группы:

#### Встроенные типы ####
Это типы, которые уже имеются в языке программирования:

+ Логический тип: bool (хранит значения true или false).
+ Символьный тип: char, wchar_t, char16_t, char32_t (хранят символы в различных кодировках).
+ Целочисленные типы: int, short, long (для хранения целых чисел).
+ Типы с плавающей запятой: float, double (для хранения дробных чисел).
#### Пользовательские типы ####
Это типы, которые программист создает самостоятельно, комбинируя встроенные типы и задавая правила их взаимодействия. Например:

+ Классы.
+ Структуры.
+ Перечисления (enum).

## 7. Какие бывают виды констант? Чем они отличаются? Какие существуют ограничения? ##
### Виды констант и их отличия: ###
#### Константы времени исполнения (runtime constants) ####

Их значение вычисляется во время выполнения программы.
Могут быть объявлены с использованием ключевого слова const.
Такие константы могут зависеть от переменных, значение которых известно только во время выполнения программы.
Пример:
```cpp
int b = 2;
const int N = 10;
const int M = N / b; // Значение M вычисляется при выполнении программы
```
#### Константы времени компиляции (compile-time constants) ####

Их значение вычисляется во время компиляции.
Для их объявления используется ключевое слово constexpr.
Константы времени компиляции должны быть однозначными и не могут зависеть от переменных, значения которых вычисляются во время выполнения программы.
Пример:

```cpp
constexpr int N = 10;
constexpr int M = N * 2; // Вычисляется во время компиляции
```

Пример ошибки:
```cpp
int b = 2;
constexpr int N = b; // Ошибка: значение `b` не известно во время компиляции
```

#### Основные отличия: #### 
Время вычисления значения:
Константы времени исполнения вычисляются во время выполнения программы, а времени компиляции — на этапе компиляции.
Зависимость от переменных:
Константы времени компиляции не могут зависеть от переменных, чьи значения не известны на этапе компиляции.
#### Ограничения: ####
Для констант времени компиляции:

Должны быть однозначными и определяться только из других констант времени компиляции.
Нельзя использовать значения, зависящие от состояния программы во время выполнения.
Для констант времени исполнения:

Инициализируются только один раз, при создании.
После инициализации их значение нельзя изменить, но они могут быть основаны на переменных.

## 8. Что такое область видимости? Что является единицей области видимости в С++? Привести пример видимости переменных во вложенных и параллельных областях видимости. ##
#### Область видимости в C++ ####
+ Область видимости — это правило, определяющее, где переменная доступна для использования. Единицей области видимости является блок кода {}.

#### Основные правила: ####
+ Родительская область: переменные видны в дочерних блоках.
+ Дочерняя область: переменные видны только внутри блока и его вложенных областях.
+ Параллельная область: переменные видны только в своем блоке и вложенных в него.
+ Замещение: переменная в дочерней области с тем же именем скрывает переменную из родительской области.
